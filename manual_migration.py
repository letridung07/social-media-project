import uuid
import datetime
import os
import sys
import subprocess

# 1. Define the latest revision ID
latest_revision_id = 'e03445f75a10'

# 2. Generate a new unique ID for this revision
new_revision_id = uuid.uuid4().hex[:12]

# 3. Get current UTC datetime for the file
current_datetime_utc = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d %H:%M:%S.%f")

# 4. Construct the migration script content
migration_script_content = f"""\"\"\"Add VirtualGood and UserVirtualGood models

Revision ID: {new_revision_id}
Revises: {latest_revision_id}
Create Date: {current_datetime_utc}

\"\"\"
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '{new_revision_id}'
down_revision = '{latest_revision_id}'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('virtual_good',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('price', sa.Numeric(precision=10, scale=2), nullable=False),
    sa.Column('currency', sa.String(length=10), nullable=False),
    sa.Column('type', sa.String(length=50), nullable=False),
    sa.Column('image_url', sa.String(length=255), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True, server_default=sa.text('(CURRENT_TIMESTAMP)')),
    sa.Column('updated_at', sa.DateTime(), nullable=True, server_default=sa.text('(CURRENT_TIMESTAMP)')),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('user_virtual_good',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('virtual_good_id', sa.Integer(), nullable=False),
    sa.Column('purchase_date', sa.DateTime(), nullable=True, server_default=sa.text('(CURRENT_TIMESTAMP)')),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.Column('is_equipped', sa.Boolean(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
    sa.ForeignKeyConstraint(['virtual_good_id'], ['virtual_good.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('user_id', 'virtual_good_id', name='_user_virtual_good_uc')
    )
    with op.batch_alter_table('user_virtual_good', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_user_virtual_good_user_id'), ['user_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_user_virtual_good_virtual_good_id'), ['virtual_good_id'], unique=False)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('user_virtual_good', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_user_virtual_good_virtual_good_id'))
        batch_op.drop_index(batch_op.f('ix_user_virtual_good_user_id'))

    op.drop_table('user_virtual_good')
    op.drop_table('virtual_good')
    # ### end Alembic commands ###
"""

# 5. Define the filename for the new migration script
migrations_versions_path = "/app/migrations/versions"
os.makedirs(migrations_versions_path, exist_ok=True) # Ensure it exists
migration_filename = f"{migrations_versions_path}/{new_revision_id}_add_virtualgood_and_uservirtualgood_models.py"

# 6. Create the new migration file with the content
with open(migration_filename, 'w') as f:
    f.write(migration_script_content)

print(f"Successfully created migration file: {migration_filename}")

# 7. Attempt to run flask db upgrade
# Setup environment based on what Python os.getenv reports
effective_home = os.getenv('HOME', '/home/swebot')
user_bin_path = os.path.join(effective_home, ".local/bin")
user_site_packages = os.path.join(effective_home, ".local/lib/python3.10/site-packages")

env = os.environ.copy()
env["PATH"] = f"{user_bin_path}:{env.get('PATH', '')}"
env["PYTHONPATH"] = f"{user_site_packages}:{env.get('PYTHONPATH', '')}"

# The flask executable might have been installed by 'jules' (from whoami in bash)
# So, ensure /home/jules/.local/bin is also in PATH for finding flask itself.
actual_user_whoami_home_for_bin = "/home/jules"
actual_user_whoami_bin_path = os.path.join(actual_user_whoami_home_for_bin, ".local/bin")
if actual_user_whoami_bin_path not in env["PATH"]:
     env["PATH"] = f"{actual_user_whoami_bin_path}:{env['PATH']}"

print(f"Script's effective user for paths: Python sees HOME as {effective_home}")
print(f"Attempting with PATH: {env['PATH']}")
print(f"Attempting with PYTHONPATH: {env['PYTHONPATH']}")

try:
    if os.getcwd() != "/app":
        os.chdir("/app") # Ensure CWD is /app for flask commands
    print("Listing files in current directory (/app) before flask db upgrade:")
    ls_result = subprocess.run(["ls", "-la"], check=True, text=True, capture_output=True, env=env)
    print(ls_result.stdout)

    # Attempt to ensure dependencies are where Python (as effective_home user) expects them
    print(f"Ensuring packages are in {user_site_packages} using pip with --target...")
    # This pip command will run as the user this script is running as (jules, per whoami)
    # but it will install to swebot's path due to HOME=/home/swebot if --user is used,
    # or to the target path if specified. --target is more explicit.
    pip_install_cmd = [
        sys.executable, "-m", "pip", "install",
        f"--target={user_site_packages}",
        "--upgrade", "--no-cache-dir", # Removed --ignore-installed for now, let pip manage upgrades
        "Flask", "Flask-Migrate", "Flask-SQLAlchemy", "SQLAlchemy",
        "passlib", "itsdangerous", "Flask-Login", "Flask-Caching",
        "Flask-WTF", "email_validator", "Flask-SocketIO", "Flask-Mail", "bootstrap-flask"
    ]
    subprocess.run(pip_install_cmd, check=True, text=True, capture_output=False, env=env)
    print("Finished pip install attempt to effective_home's site-packages.")

    print("Attempting flask db upgrade...")
    # Prefer flask from actual_user_whoami_bin_path as 'whoami' in bash was jules
    flask_exe_actual_user = os.path.join(actual_user_whoami_bin_path, "flask")
    flask_exe_effective_home = os.path.join(user_bin_path, "flask") # Path for swebot context

    if os.path.exists(flask_exe_actual_user):
        flask_command_list = [flask_exe_actual_user, "db", "upgrade"]
        print(f"Using flask executable at {flask_exe_actual_user}")
    elif os.path.exists(flask_exe_effective_home):
        flask_command_list = [flask_exe_effective_home, "db", "upgrade"]
        print(f"Using flask executable at {flask_exe_effective_home}")
    else:
        print(f"Flask executable not found in {actual_user_whoami_bin_path} or {user_bin_path}. Trying global 'flask'.")
        flask_command_list = ["flask", "db", "upgrade"]

    result = subprocess.run(flask_command_list, check=True, text=True, capture_output=True, env=env)
    print("Flask db upgrade STDOUT:")
    print(result.stdout)
    if result.stderr:
        print("Flask db upgrade STDERR:")
        print(result.stderr)
    print("Successfully applied database migration.")

except FileNotFoundError as e:
    print(f"Error: flask command not found. Ensure it's installed and in PATH. Details: {e}")
    find_flask_result = subprocess.run(["which", "flask"], text=True, capture_output=True, env=env)
    print(f"Result of 'which flask': {find_flask_result.stdout.strip() if find_flask_result.stdout else 'Not found'}")
    raise
except subprocess.CalledProcessError as e:
    print(f"Error during command: {e.cmd}. Return code: {e.returncode}")
    print("STDOUT:")
    print(e.stdout)
    print("STDERR:")
    print(e.stderr)
    if "ModuleNotFoundError: No module named 'bootstrap_flask'" in e.stderr:
        print("The 'bootstrap_flask' ModuleNotFoundError is still present.")
        try:
            print("Attempting direct import of bootstrap_flask in subprocess...")
            # Ensure the env for this check is the same as for the flask command
            import_check_cmd = [sys.executable, "-c", f"import sys; print(f'--- sys.path for import check: {{sys.path}} ---'); import bootstrap_flask; print(bootstrap_flask.__file__)"]
            import_check_result = subprocess.run(import_check_cmd, check=True, text=True, capture_output=True, env=env)
            print("Direct import successful. bootstrap_flask location:", import_check_result.stdout)
        except subprocess.CalledProcessError as import_err:
            print("Direct import failed. STDERR from import check:", import_err.stderr)
            print("STDOUT from import check:", import_err.stdout)
    raise
except Exception as e:
    print(f"An unexpected error occurred: {type(e).__name__} - {e}")
    raise

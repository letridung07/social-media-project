from datetime import datetime, timedelta, timezone
from app import db
from app.core.models import User, Application, AccessToken # OAuth models
import secrets # For generating tokens if not done in model

# Configuration for token expiry (e.g., 1 hour)
ACCESS_TOKEN_EXPIRES_IN_SECONDS = 3600

def generate_access_token(user, application, scopes=None):
    """
    Generates a new access token for a given user and application.
    """
    # The AccessToken model already generates a token string automatically upon init.
    # It also sets created_at. We need to set expires_at.
    expires_at = datetime.now(timezone.utc) + timedelta(seconds=ACCESS_TOKEN_EXPIRES_IN_SECONDS)

    # The AccessToken model's __init__ handles token generation.
    # We might need to ensure refresh token generation if applicable,
    # but for client_credentials, it's often not used or generated separately.

    # For client_credentials grant, the 'user' here is typically the owner of the application.
    access_token = AccessToken(
        user_id=user.id,
        application_id=application.id,
        # token field is auto-generated by the AccessToken model constructor
        expires_at=expires_at,
        scopes=scopes # Store scopes as a space-separated string or handle as JSON
    )
    db.session.add(access_token)
    db.session.commit()
    return access_token.token # Return the plain token string

def validate_access_token(token_string):
    """
    Validates an access token.
    Returns (user, application) if valid, otherwise None.
    """
    if not token_string:
        return None

    access_token = AccessToken.query.filter_by(token=token_string).first()

    if not access_token:
        return None

    # Check if token is expired
    if access_token.expires_at < datetime.now(timezone.utc):
        # Optionally, clean up expired tokens
        db.session.delete(access_token)
        db.session.commit()
        return None

    # Check if token was revoked (if an is_revoked field exists and is True)
    # if hasattr(access_token, 'is_revoked') and access_token.is_revoked:
    #     return None

    # Token is valid, return the associated user and application
    # Ensure user and application are loaded. They should be due to the relationships.
    if not access_token.user or not access_token.application:
        # Data integrity issue if this happens
        return None

    return access_token.user, access_token.application

# Placeholder for the decorator, will be implemented later
# from functools import wraps
# from flask import request, jsonify, g

# def token_required(f):
#     @wraps(f)
#     def decorated_function(*args, **kwargs):
#         # Implementation here
#         pass
    return decorated_function

from functools import wraps
from flask import request, jsonify, g

def token_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        token_string = None

        if auth_header and auth_header.startswith('Bearer '):
            token_string = auth_header.split(' ', 1)[1]

        if not token_string:
            return jsonify({"error": "unauthorized", "error_description": "Missing or invalid authorization token"}), 401

        validation_result = validate_access_token(token_string)
        if not validation_result:
            return jsonify({"error": "unauthorized", "error_description": "Invalid or expired token"}), 401

        user, application = validation_result
        g.current_user = user
        g.current_application = application

        return f(*args, **kwargs)
    return decorated_function

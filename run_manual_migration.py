import os
import datetime
import secrets

# 1. Define the migration script content
migration_script_content_template = """\"\"\"Add livestream enhancements

Revision ID: {new_revision_id}
Revises: 83e952279f55
Create Date: {create_date}

\"\"\"
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '{new_revision_id}'
down_revision = '83e952279f55'
branch_labels = None
depends_on = None

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('live_streams', schema=None) as batch_op:
        batch_op.add_column(sa.Column('recording_filename', sa.String(length=255), nullable=True))
        batch_op.add_column(sa.Column('media_server_url', sa.String(length=255), nullable=True))
        batch_op.add_column(sa.Column('stream_conversation_id', sa.Integer(), nullable=True))
        # Add enable_recording with server_default and nullable=False for consistency
        batch_op.add_column(sa.Column('enable_recording', sa.Boolean(), nullable=False, server_default=sa.false()))

        # Explicitly name the foreign key constraint for better control
        batch_op.create_foreign_key(
            'fk_live_streams_stream_conversation_id_conversations',
            'conversations',
            ['stream_conversation_id'],
            ['id']
        )
        # Explicitly name the unique constraint
        batch_op.create_unique_constraint(
            'uq_live_streams_stream_conversation_id',
            ['stream_conversation_id']
        )

    # Update existing rows to set enable_recording to False if it's NULL
    # (which they would be if column was added as nullable initially without server_default)
    # Since we add it with server_default=sa.false() and nullable=False, this explicit update
    # might only be necessary if there was an intermediate state.
    # For safety and to ensure all existing rows are compliant:
    op.execute("UPDATE live_streams SET enable_recording = FALSE WHERE enable_recording IS NULL")

    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('live_streams', schema=None) as batch_op:
        batch_op.drop_constraint('uq_live_streams_stream_conversation_id', type_='unique')
        batch_op.drop_constraint('fk_live_streams_stream_conversation_id_conversations', type_='foreignkey')
        batch_op.drop_column('enable_recording')
        batch_op.drop_column('stream_conversation_id')
        batch_op.drop_column('media_server_url')
        batch_op.drop_column('recording_filename')
    # ### end Alembic commands ###
"""

# 2. Generate new revision ID and create date
new_rev_id = secrets.token_hex(6) # Generates a 12-character hex string
create_timestamp = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d %H:%M:%S.%f")

migration_script_content = migration_script_content_template.format(
    new_revision_id=new_rev_id,
    create_date=create_timestamp
)

# 3. Create the new migration file
migrations_dir = "migrations/versions"
if not os.path.exists(migrations_dir):
    os.makedirs(migrations_dir) # Should exist, but good practice

new_migration_filename = f"{new_rev_id}_add_livestream_enhancements.py"
new_migration_filepath = os.path.join(migrations_dir, new_migration_filename)

with open(new_migration_filepath, "w") as f:
    f.write(migration_script_content)

print(f"Created new migration file: {new_migration_filepath}")

# 4. Attempt to run flask db upgrade
# First, ensure Flask and dependencies are available.
# The previous subtask reported issues with module discovery.
# We will try to set PYTHONPATH explicitly.
import sys
import os
# Add project root to Python path, assuming script runs from project root
project_root = os.getcwd()
if project_root not in sys.path:
    sys.path.insert(0, project_root)
# Also add the 'app' directory if your Flask app object is there and that helps discovery
app_dir = os.path.join(project_root, 'app')
if app_dir not in sys.path:
     sys.path.insert(0, app_dir)

print(f"Python path: {sys.path}")
print(f"Current working directory: {os.getcwd()}")

# Set FLASK_APP environment variable
os.environ['FLASK_APP'] = 'run.py' # Or your actual Flask app entry point

# Attempt to run flask db upgrade
import subprocess
try:
    # Install flask-migrate just in case, though it should be in requirements.txt
    # subprocess.run([sys.executable, "-m", "pip", "install", "flask-migrate"], check=True, capture_output=True, text=True)
    # print("Flask-Migrate install attempted.")

    # Check if flask command is accessible
    # result_check = subprocess.run(["flask", "--version"], capture_output=True, text=True)
    # print(f"Flask version check: {result_check.stdout} {result_check.stderr}")

    result = subprocess.run(["flask", "db", "upgrade"], check=True, capture_output=True, text=True)
    print("Flask db upgrade successful.")
    print("Output:", result.stdout)
except subprocess.CalledProcessError as e:
    print(f"Error during flask db upgrade: {e}")
    print("Stderr:", e.stderr)
    print("Stdout:", e.stdout)
    raise # Re-raise to mark subtask as failed if upgrade fails
except FileNotFoundError:
    print("Error: 'flask' command not found. Ensure Flask is installed and in PATH.")
    print("Attempting to run as python -m flask db upgrade")
    try:
        result = subprocess.run([sys.executable, "-m", "flask", "db", "upgrade"], check=True, capture_output=True, text=True)
        print("python -m flask db upgrade successful.")
        print("Output:", result.stdout)
    except subprocess.CalledProcessError as e_mod:
        print(f"Error during python -m flask db upgrade: {e_mod}")
        print("Stderr:", e_mod.stderr)
        print("Stdout:", e_mod.stdout)
        raise # Re-raise to mark subtask as failed
    except FileNotFoundError as e_fnf_mod:
        print(f"Error: sys.executable not found or python -m flask failed: {e_fnf_mod}")
        raise

print("Subtask finished attempting migration.")
